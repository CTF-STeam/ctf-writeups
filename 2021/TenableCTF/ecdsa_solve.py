from ecdsa.numbertheory import inverse_mod
from Crypto.Cipher import AES
import binascii

n = 115792089210356248762697446949407573529996955224135760342422259061068512044369

r = 50394691958404671760038142322836584427075094292966481588111912351250929073849
s1 = 26685296872928422980209331126861228951100823826633336689685109679472227918891
s2 = 40762052781056121604891649645502377037837029273276315084687606790921202237960

z1 = 777971358777664237997807487843929900983351335441289679035928005996851307115
z2 = 91840683637030200077344423945857298017410109326488651848157059631440788354195

ct = b'f3ccfd5877ec7eb886d5f9372e97224c43f4412ca8eaeb567f9b20dd5e0aabd5'

sdelta_inv = inverse_mod(((s1 - s2) % n), n)
k = (((z1 - z2) % n) * sdelta_inv) % n
inverse_r = inverse_mod(r, n)
da = (((((s1 * k) % n) - z1) % n) * inverse_r) % n
print(da)
#secret = SigningKey.from_secret_exponent(da)
secret = int(da)
print(secret)

aes_key = secret.to_bytes(64, byteorder='little')[0:16]

IV = b'\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'
cipher = AES.new(aes_key, AES.MODE_CBC, IV)
pt = cipher.decrypt(binascii.unhexlify(ct))
print(pt)
